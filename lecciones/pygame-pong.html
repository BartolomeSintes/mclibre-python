<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8">
  <title>Pong. pygame. Python. Bartolomé Sintes Marco. www.mclibre.org</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="../varios/python.css" title="mclibre">
  <link rel="icon" href="../varios/favicon.svg">
  <link rel="stylesheet" href="../varios/prism.css">
  <script src="../varios/prism.js"></script>
</head>

<body>
  <h1>Pygame: Pong</h1>

  <nav>
    <p>
      <a href="../index.html"><img src="../varios/iconos/icono-python.svg" alt="Índice de Python" title="Índice de Python" width="48" height="48"></a>
      <a href="#"><img src="../varios/iconos/icono-arrow-circle-up.svg" alt="Principio de la página" title="Principio de la página" width="36" height="36"></a>
    </p>

    <div class="toc">
      <h2>Pygame: Pong</h2>

      <ul>
        <li><a href="#historia">Historia de Pong</a></li>
        <li><a href="#pygame">La biblioteca Pygame</a></li>
        <li><a href="#instalacion">Instalación de Pygame</a></li>
        <li><a href="#programacion">Programación del juego</a>
          <ul>
            <li><a href="#programacion-1">1: Ventana de juego</a></li>
            <li><a href="#programacion-2">2: Clase PelotaPong</a></li>
            <li><a href="#programacion-3">3: Rebote de la pelota</a></li>
            <li><a href="#programacion-4">4: Reiniciar pelota al salir</a></li>
            <li><a href="#programacion-5">5: Clase RaquetaPong</a></li>
            <li><a href="#programacion-6">6: Mover raqueta con teclas</a></li>
            <li><a href="#programacion-7">7: Golpear pelota (humano)</a></li>
            <li><a href="#programacion-8">8: Jugador IA</a></li>
            <li><a href="#programacion-9">9: Mostrar puntuación</a></li>
          </ul>
        </li>
        <li><a href="#pendiente">Detalles pendientes</a></li>
      </ul>
    </div>
  </nav>

  <p class="incompleto"><img src="../varios/iconos/icono-en-construccion.svg" alt="En construcción" title="En construcción" width="55" height="48">Esta lección está en elaboración</p>

  <p>Esta lección es un tutorial de la biblioteca pygame, en el que se programa el juego clásico Pong.</p>

  <section id="historia">
    <h2>Historia de Pong</h2>

    <p>Aunque desde la aparición de los ordenadores programables en los años 40 del siglo XX se han escrito programas que podían considerarse juegos, se suele considerar que el primer videojuego fue <a href="https://en.wikipedia.org/wiki/Tennis_for_Two">Computer Tennis</a>. Este videojuego fue creado en 1958 para la exposición anual del Laboratorio Nacional de Brookhaven (EEUU) y simulaba un pista de tenis vista lateralmente. El juego se visualizaba en la pantalla de un osciloscopio y se convirtió en la mayor atracción de esa exposición. Aunque al año siguiente la exposición contó con una versión mejorada del juego, el equipo se acabó desmontando para reutilizar los componentes en el Laboratorio.</p>

    <p>Bastante años después, en septiembre de 1972, se comercializó la primera videoconsola de la historia dirigida a los hogares, <a href="https://en.wikipedia.org/wiki/Magnavox_Odyssey">Magnavox Odyssey</a>. Esta videoconsola se conectaba a una pantalla de televisor y uno de los juegos incluidos era Table Tennis. En este juego cada jugador controlaba una paleta que golpeaba una pelota. El mismo año, pero en noviembre, la compañía Atari comercializó <a href="https://es.wikipedia.org/wiki/Pong">Pong</a>, una de las primeras máquinas de <a href="https://es.wikipedia.org/wiki/Arcade">arcade</a>, destinadas a lugares públicos.</p>

    <p><img src="../img/pygame/pong.png" alt="Pong, el videojuego" width="240" height="180" class="derecha">Con Pong, un juego trivial para los estándares actuales, empezaba la era moderna de los videojuegos. Pong es un juego de deportes en dos dimensiones que simula un tenis de mesa. El jugador controla en el juego una paleta moviéndola verticalmente en la parte izquierda de la pantalla, y puede competir tanto contra un oponente controlado por computadora, como con otro jugador humano que controla una segunda paleta en la parte opuesta. Los jugadores pueden usar las raquetas para pegarle a la pelota hacia un lado u otro. El objetivo consiste en que uno de los jugadores consiga más puntos que el oponente al finalizar el juego. Estos puntos se obtienen cuando el jugador adversario falla al devolver la pelota.</p>

    <p>La palabra Pong es una marca registrada por Atari Interactive (aunque la patente del juego la tuvo la empresa de Magnavox Odyssey), pero la palabra genérica "pong" se usa para describir el género de videojuegos.</p>

    <p>Por todo ello, cuando se aprende a programar videojuegos, es habitual comenzar programando un juego como Pong, por su sencillez y también como homenaje al gran clásico.</p>
  </section>

  <section id="pygame">
    <h2>Pygame</h2>

    <p><img src="../img/pygame/pygame-logo.png" alt="Logotipo pygame" width="202" height="80" class="izquierda"><a href="https://www.pygame.org/news">Pygame</a> es un conjunto de módulos de Python que facilitan la creación de videojuegos. Pygame utiliza internamente la biblioteca <a href="http://www.libsdl.org/">SDL</a> (Simple DirectMedia Layer), escrita principalmente en C.</p>

    <p>Pygame se distribuye bajo la licencia libre LGPL, lo que permite utilizarla tanto en proyecto libres como comerciales.</p>

    <p>Además de la <a href="http://www.pygame.org/docs/">Documentación oficial de pygame</a>, en Internet se pueden encontrar sitios y libros dedicados a la introducción a la programación en general, o a la introducción a la programación de videojuegos en particular, mediante pygame, como los siguientes:</p>

    <ul>
      <li><a href="http://programarcadegames.com/">Programar Juegos Arcade con Python y Pygame</a></li>
      <li><a href="http://inventwithpython.com/pygame/index.html">Making Games with Python &amp; Pygame</a></li>
    </ul>
  </section>

  <section id="instalacion">
    <h2>Instalación de pygame</h2>

    <p>Los pasos para instalar pygame como módulo de sistema en Windows son los siguientes:</p>
    <ul>
      <li>Abra una ventana de terminal y escriba los siguientes comandos.</li>
      <li>Actualice <a href="https://pip.pypa.io/en/stable/">pip</a>:
        <div class="terminal">
          <pre class="command-line" data-prompt="C:\>">
<code class="language-shell">python -m pip install --upgrade pip</code>
</pre>
        </div>
      </li>
      <li>Instale <a href="https://www.pygame.org/news">pygame</a>:
        <div class="terminal">
          <pre class="command-line" data-prompt="C:\>">
<code class="language-shell">pip install pygame</code>
</pre>
        </div>
      </li>
    </ul>
  </section>

  <section id="programacion">
    <h2>Realización del programa</h2>

    <p>Vamos a programar un juego de Pong en el que una de las raquetas esté controlada por el jugador humano mediante el teclado y la otra raqueta esté contralada por el propio programa.</p>

    <p>Para la realización del juego Pong, iremos por fases, implementando en cada paso uno de los elementos del programa.</p>

    <section id="programacion-1">
      <h3>Paso 1: Ventana de juego</h3>

      <p>El juego se ejecutará en una ventana independiente. Para crear la ventana, necesitamos bastante código específico de pygame, que no es necesario conocer de memoria, ya que lo podemos reutilizar de un proyecto a otro.</p>

      <p>El siguiente programa genera una ventana en blanco con el título del juego, similar a la captura siguiente (la ventana está recortada en la captura).</p>

      <p class="captura">
        <img src="../img/pygame/pong-1-1.png" alt="Pygame - Pong 1" width="802" height="200">
      </p>

      <div class="codigo copy">
        <pre class="line-numbers">
<code class="language-python"># pong_1_1.py: Ventana de juego

import pygame
from pygame.locals import QUIT

# Constantes para la inicialización de la superficie de dibujo
VENTANA_HORI = 800  # Ancho de la ventana
VENTANA_VERT = 600  # Alto de la ventana
FPS = 60  # Fotogramas por segundo
BLANCO = (255, 255, 255)  # Color del fondo de la ventana (RGB)


def main():
    # Inicialización de Pygame
    pygame.init()

    # Inicialización de la superficie de dibujo (display surface)
    ventana = pygame.display.set_mode((VENTANA_HORI, VENTANA_VERT))
    pygame.display.set_caption("Pong 1")

    # Bucle principal
    jugando = True
    while jugando:
        ventana.fill(BLANCO)

        for event in pygame.event.get():
            if event.type == QUIT:
                jugando = False

        pygame.display.flip()
        pygame.time.Clock().tick(FPS)

    pygame.quit()


if __name__ == "__main__":
    main()</code>
</pre>
      </div>

      <p>Cada una de las instrucciones tiene una función específica, que se comenta a continuación:</p>
      <ul>
        <li>Importación de módulos
          <div class="codigo">
            <pre class="line-numbers" data-start="3">
<code class="language-python">import pygame
from pygame.locals import *</code>
</pre>
          </div>

          <p>Importamos los módulos pygame. Para que al hacer referencia en el programa a las constantes de pygame no tengamos que incluir el nombre del módulo, las importamos todas del módulo pygame.locals.</p>

        </li>
        <li>Definición de constantes
          <div class="codigo">
            <pre class="line-numbers" data-start="6">
<code class="language-python"># Constantes para la inicialización de la superficie de dibujo
VENTANA_HORI = 800  # Ancho de la ventana
VENTANA_VERT = 600  # Alto de la ventana
FPS = 60  # Fotogramas por segundo
BLANCO = (255, 255, 255)  # Color del fondo de la ventana (RGB)</code>
</pre>
          </div>
          <p>Python no tiene un tipo de dato "constante" (es decir, un valor que no se pueda modificar). La costumbre, heredada de otros lenguajes, es simplemente escribir el nombre de una variable en mayúsculas para indicar a quien lea nuestro código fuente que esa variable no se va a modificar en ningún momento del programa. Definimos así varias constantes:</p>
          <ul>
            <li>El tamaño de la ventana de juego (en este caso, 800 x 600 px, la llamada <a href="https://es.wikipedia.org/wiki/Super_Video_Graphics_Array">resolución SVGA</a> original).</li>
            <li>Normalmente FPS hace referencia al número de veces por segundo que se actualiza la imagen en la ventana. En principio, cuanto más alto es ese valor, mejor se verán los objetos en movimiento, aunque cada pantalla admite un valor máximo y dependiendo de la complejidad de la creación de la imagen puede que no se puedan alcanzar valores muy altos. En pygame, la ventana se está actualizando constantemente y en cada actualización los objetos se desplazan, por lo que si la ventana se actualiza demasiadas veces, los objetos se desplazarán demasiado rápido. Para evitarlo, en pygame FPS significa el número máximo de veces que queremos que se actualice la ventana, aunque si debido a la complejidad de la imagen el número de veces que se actualiza la imagen es inferior, pygame no podrá alcanzar ese número.</li>
            <li>En pygame los colores se indican mediante códigos RGB, así que definimos una constante con el nombre del color para facilitar su referencia.</li>
          </ul>
        </li>
        <li>Inicialización
          <div class="codigo">
            <pre class="line-numbers" data-start="14">
<code class="language-python">    # Inicialización de Pygame
    pygame.init()

    # Inicialización de la superficie de dibujo (display surface)
    ventana = pygame.display.set_mode((VENTANA_HORI, VENTANA_VERT))
    pygame.display.set_caption("Pong 1")</code>
</pre>
          </div>
          <p>Con estas instrucciones:</p>
          <ul>
            <li>Inicializamos pygame.</li>
            <li>Creamos el objeto <i>ventana</i> que nos permite acceder al contenido de la ventana (al crearlo, le indicamos su tamaño).</li>
            <li>Le damos un título a la ventana.</li>
          </ul>
        </li>
        <li>Bucle principal
          <div class="codigo">
            <pre class="line-numbers" data-start="21">
<code class="language-python">    # Bucle principal
    jugando = True
    while jugando:
        ventana.fill(BLANCO)

        for event in pygame.event.get():
            if event.type == QUIT:
                jugando = False

        pygame.display.flip()
        pygame.time.Clock().tick(FPS)

    pygame.quit()</code>
</pre>
          </div>
          <p>El bucle principal se ejecuta continuamente:</p>
          <ul>
            <li>línea 22: La variable lógica <i>jugando</i> controlará la repetición del bucle. Inicialmente, la variable tiene el valor <span class="idle-rese">True</span>.</li>
            <li>línea 23: Mientras se mantenga ese valor, el bucle se repetirá.</li>
            <li>línea 24: En cada iteración pintamos la pantalla de blanco para borrar los elementos de la imagen anterior (en este programa todavía no ha elementos, pero podemos añadir ya esta instrucción).</li>
            <li>líneas 26 a 28: Las pulsaciones de tecla o del ratón se reciben en forma de <i>eventos</i>.
              <ul>
                <li>línea 26: El bucle <span class="idle-rese">for</span> recorre en cada iteración los eventos recibidos</li>
                <li>línea 27: Si el evento es de tipo QUIT (es decir, que se ha cerrado la ventana del juego, con el ratón o con el atajo de teclado <span class="soft-atajo-teclado">Alt+F4</span>) ...</li>
                <li>línea 28: La variable <i>jugando</i> pasa a <span class="idle-rese">False</span>, por lo que el bucle <span class="idle-rese">while</span> no se volverá a ejecutar.</li>
              </ul>
            </li>
            <li>línea 30: Todos los elementos de la pantalla se vuelven a dibujar (en este programa todavía no ha elementos, pero podemos añadir ya esta instrucción).</li>
            <li>línea 31: Con esta instrucción pygame comprueba que la ejecución se mantiene en el número de FPS y no va demasiado rápida.</li>
            <li>línea 33: Si hemos salido del bucle es que se ha cerrado la ventana, así que con esta instrucción le pedimos a pygame que cierre todos sus procesos.</li>
          </ul>
        </li>
      </ul>
    </section>

    <section id="programacion-2">
      <h3>Paso 2: Clase PelotaPong</h3>

      <p>El primer elemento del juego que programaremos será la pelota. Para definir la pelota crearemos una clase a la que llamaremos PelotaPong. Las clases son propias de la programación orientada a objetos y permiten ampliar los tipos de datos del lenguaje. Una vez definida la clase, podemos crear tantas variables de esa clase como queramos (por ejemplo, una o varias pelotas, en el caso de que quisiéramos jugar con varias pelotas a la vez).</p>

      <p>El siguiente programa dibuja una pelota cuadrada de color rojo en el centro de la ventana y la desplaza en línea recta en una de las cuatro direcciones diagonales. Cuando llega al borde de la ventana, la pelota deja de verse aunque sigue moviéndose indefinidamente en la misma dirección.</p>

      <p class="captura">
        <img src="../img/pygame/pong-1-2-1.png" alt="Pygame - Pong 2" width="802" height="200">
      </p>

      <p>Para situar los objetos en la ventana pygame utiliza un sistema de coordenadas cartesianas en el que el origen se encuentran en la esquina superior izquierda de la ventana y en el que el eje vertical está dirigido hacia abajo. De esta manera, los valores de las coordenadas serán siempre positivos: cuanto mayor sea la coordenada <i>x</i> más a la derecha estará el objeto y cuanto mayor sea la coordenada <i>y</i> más hacia abajo estará el objeto. Si se asignan valores negativos o mayores que el tamaño de la ventana, no se produce ningún error, pero el objeto simplemente no se verá (dependiendo del tamaño que tenga y de los valores utilizados, el objeto puede verse parcialmente).</p>

      <p class="mcl-svg-figura">
        <svg version="1.1" xmlns="http://www.w3.org/2000/svg" width="815" height="200" viewBox="-10 -35 815 200" style="background-color: #eeeeee">
          <image x="-1" y="-31" width="802" height="200" xlink:href="../img/pygame/pong-1-2-1.png" />
          <line x1="-20" y1="0" x2="600" y2="0" stroke="red" stroke-width="1" />
          <polyline points="590,5 600,0 590,-5" fill="none" stroke-width="1" stroke="red" />
          <text x="580" y="25" font-family="sans-serif" font-size="20" fill="red">X</text>
          <line x1="0" y1="-40" x2="0" y2="150" stroke="red" stroke-width="1" />
          <polyline points="-5,140 0,150 5,140" fill="none" stroke-width="1" stroke="red" />
          <text x="10" y="140" font-family="sans-serif" font-size="20" fill="red">Y</text>
        </svg>
      </p>

      <div class="codigo copy">
        <pre class="line-numbers">
<code class="language-python"># pong_1_2.py: Clase PelotaPong

import random
import pygame
from pygame.locals import QUIT

# Constantes para la inicialización de la superficie de dibujo
VENTANA_HORI = 800  # Ancho de la ventana
VENTANA_VERT = 600  # Alto de la ventana
FPS = 60  # Fotogramas por segundo
BLANCO = (255, 255, 255)  # Color del fondo de la ventana (RGB)


class PelotaPong:
    def __init__(self, fichero_imagen):
        # --- Atributos de la Clase ---

        # Imagen de la Pelota
        self.imagen = pygame.image.load(fichero_imagen).convert_alpha()

        # Dimensiones de la Pelota
        self.ancho, self.alto = self.imagen.get_size()

        # Posición de la Pelota
        self.x = VENTANA_HORI / 2 - self.ancho / 2
        self.y = VENTANA_VERT / 2 - self.alto / 2

        # Dirección de movimiento de la Pelota
        self.dir_x = random.choice([-5, 5])
        self.dir_y = random.choice([-5, 5])

    def mover(self):
        self.x += self.dir_x
        self.y += self.dir_y


def main():
    # Inicialización de Pygame
    pygame.init()

    # Inicialización de la superficie de dibujo (display surface)
    ventana = pygame.display.set_mode((VENTANA_HORI, VENTANA_VERT))
    pygame.display.set_caption("Pong 2")

    pelota = PelotaPong("bola_roja.png")

    # Bucle principal
    jugando = True
    while jugando:
        pelota.mover()

        ventana.fill(BLANCO)
        ventana.blit(pelota.imagen, (pelota.x, pelota.y))

        for event in pygame.event.get():
            if event.type == QUIT:
                jugando = False

        pygame.display.flip()
        pygame.time.Clock().tick(FPS)

    pygame.quit()


if __name__ == "__main__":
    main()</code>
</pre>
      </div>

      <p>Las instrucciones añadidas con respecto al paso 1 son las siguientes:</p>
      <ul>
        <li>Importación de módulos
          <div class="codigo">
            <pre class="line-numbers" data-start="3">
<code class="language-python">import random</code>
</pre>
          </div>

          <p>Importamos el módulo random, que utilizaremos en el programa.</p>

        </li>
        <li>Clase PelotaPong
          <div class="codigo">
            <pre class="line-numbers" data-start="14">
<code class="language-python">class PelotaPong:
    def __init__(self, fichero_imagen):
        # --- Atributos de la Clase ---

        # Imagen de la Pelota
        self.imagen = pygame.image.load(fichero_imagen).convert_alpha()

        # Dimensiones de la Pelota
        self.ancho, self.alto = self.imagen.get_size()

        # Posición de la Pelota
        self.x = VENTANA_HORI / 2 - self.ancho / 2
        self.y = VENTANA_VERT / 2 - self.alto / 2

        # Dirección de movimiento de la Pelota
        self.dir_x = random.choice([-5, 5])
        self.dir_y = random.choice([-5, 5])

    def mover(self):
        self.x += self.dir_x
        self.y += self.dir_y</code>
</pre>
          </div>
          <p>En la definición de una clase se definen los atributos y los métodos de la clase. Los atributos son variables que van asociadas automáticamente a los objetos. Los métodos son funciones que se pueden aplicar a los objetos. En la definición de la clase para hacer referencia a que los atributos son los del propio objeto se indica con <i>self</i>.</p>
          <ul>
            <li>El método <i>__init__()</i> es la función que se ejecuta automáticamente cuando se cree un objeto de la clase. Por eso, aprovechamos este método para definir los atributos de la clase. En el caso de la pelota de este juego, sus atributos serán: la imagen que se muestra en la pantalla, su tamaño, la posición en la pantalla y la dirección del movimiento:
              <ul>
                <li>Todos los métodos incluyen el argumento <i>self</i> que hace referencia al propio objeto. En este caso, también añadimos el argumento <i>imagen</i> que indicará el camino hasta el fichero de imagen de la pelota:
                  <div class="codigo">
                    <pre class="line-numbers" data-start="15">
<code class="language-python">    def __init__(self, imagen):</code>
</pre>
                  </div>
                </li>
                <li>Un atributo de la clase será <i>imagen</i>, que cargará el fichero con la imagen:
                  <div class="codigo">
                    <pre class="line-numbers" data-start="19">
<code class="language-python">        self.imagen = pygame.image.load(fichero_imagen).convert_alpha()</code>
</pre>
                  </div>
                </li>
                <li>Otros dos atributos serán el ancho y alto de la imagen, <i>ancho</i> y <i>alto</i> que se obtienen a partir del atributo <i>imagen</i> con el método <i>get_size()</i>:
                  <div class="codigo">
                    <pre class="line-numbers" data-start="22">
<code class="language-python">        self.ancho, self.alto = self.imagen.get_size()</code>
</pre>
                  </div>
                </li>
                <li>Dos atributos más serán la posición horizontal y vertical de la imagen, <i>x</i> e <i>y</i>. Inicialmente, queremos que la pelota se dibuje en el centro de la pantalla. Para ello, tenemos que tener en cuenta que cuando indicamos la posición de un objeto, estamos indicando la posición de la esquina superior izquierda de su imagen. Si el objeto es muy pequeño, no se notará la diferencia, pero lo mejor es tener en cuenta el ancho y alto del objeto, restando la mitad del tamaño del objeto a la posición del centro de la ventana.

                  <p class="mcl-svg-figura">
                    <svg version="1.1" xmlns="http://www.w3.org/2000/svg" width="820" height="240" viewBox="-10 -10 820 240" style="background-color: #eeeeee">
                      <defs>
                        <marker id="flechaRojaIni1" markerWidth="12" markerHeight="8" refX="0" refY="4" orient="auto">
                          <path d="M12,0 L0,4 L12,8" style="fill: red" />
                        </marker>
                        <marker id="flechaRojaFin1" markerWidth="12" markerHeight="8" refX="12" refY="4" orient="auto">
                          <path d="M0,0 L12,4 L0,8" style="fill: red;" />
                        </marker>
                      </defs>
                      <rect x="0" y="0" width="800" height="220" fill="white" stroke-width="1" stroke="black" />

                      <line x1="400" y1="0" x2="400" y2="220" stroke="black" stroke-width="1" stroke-dasharray="10 10" />
                      <line x1="0" y1="110" x2="800" y2="110" stroke="black" stroke-width="1" stroke-dasharray="10 10" />

                      <text x="200" y="20" text-anchor="middle" font-family="sans-serif" font-size="20" fill="black">VENTANA_HORI / 2</text>
                      <line x1="0" y1="30" x2="400" y2="30" stroke="red" stroke-width="1" style="marker-start: url(#flechaRojaIni1); marker-end: url(#flechaRojaFin1)" />
                      <text x="380" y="50" text-anchor="middle" font-family="sans-serif" font-size="20" fill="black">self.ancho / 2</text>
                      <line x1="360" y1="60" x2="400" y2="60" stroke="red" stroke-width="1" style="marker-start: url(#flechaRojaIni1); marker-end: url(#flechaRojaFin1)" />

                      <text x="520" y="60" text-anchor="start" font-family="sans-serif" font-size="20" fill="black">VENTANA_VERT / 2</text>
                      <line x1="510" y1="0" x2="510" y2="110" stroke="red" stroke-width="1" style="marker-start: url(#flechaRojaIni1); marker-end: url(#flechaRojaFin1)" />
                      <text x="485" y="90" text-anchor="middle" transform="rotate(-90 485 90)" font-family="sans-serif" font-size="20" fill="black">self.alto / 2</text>
                      <line x1="460" y1="70" x2="460" y2="110" stroke="red" stroke-width="1" style="marker-start: url(#flechaRojaIni1); marker-end: url(#flechaRojaFin1)" />

                      <rect x="360" y="70" width="80" height="80" fill="red" />
                      <circle cx="360" cy="70" r="3" fill="black" />
                    </svg>
                  </p>

                  <div class="codigo">
                    <pre class="line-numbers" data-start="25">
<code class="language-python">        self.x = VENTANA_HORI / 2 - self.ancho / 2
        self.y = VENTANA_VERT / 2 - self.alto / 2</code>
</pre>
                  </div>
                </li>
                <li>Dos atributos más serán la dirección horizontal y vertical de movimiento de la imagen, <i>dir_x</i> y <i>dir_y</i>. Numéricamente, serán los píxeles que se desplazará la pelota cada vez que se redibuje la pantalla. Inicialmente, la pelota se desplazará 5px aleatoriamente hacia arriba (-5) o hacia abajo (5), hacia la izquierda (-5) o hacia la derecha (5):
                  <div class="codigo">
                    <pre class="line-numbers" data-start="29">
<code class="language-python">        self.dir_x = random.choice([-5, 5])
        self.dir_y = random.choice([-5, 5])</code>
</pre>
                  </div>
                </li>
              </ul>
            </li>
            <li>El método <i>mover()</i> es la función que define cómo se mueve la pelota. En este caso, simplemente añadimos a las posiciones los valores de las direcciones. Este método sólo se ejecutará cuando la llamemos en el cuerpo del programa.

              <p>La imagen siguiente muestra tres posiciones sucesivas de la pelota. La pelota se desplaza cada vez <i>dir_x</i> unidades en horizontal y <i>dir_y</i> unidades en vertical.</p>

              <p class="mcl-svg-figura">
                <svg version="1.1" xmlns="http://www.w3.org/2000/svg" width="820" height="240" viewBox="-10 -10 820 240" style="background-color: #eeeeee">
                  <defs>
                    <marker id="flechaRojaIni2" markerWidth="12" markerHeight="8" refX="0" refY="4" orient="auto">
                      <path d="M12,0 L0,4 L12,8" style="fill: red" />
                    </marker>
                    <marker id="flechaRojaFin2" markerWidth="12" markerHeight="8" refX="12" refY="4" orient="auto">
                      <path d="M0,0 L12,4 L0,8" style="fill: red;" />
                    </marker>
                  </defs>
                  <rect x="0" y="0" width="800" height="220" fill="white" stroke-width="1" stroke="black" />

                  <rect x="100" y="140" width="40" height="40" fill="red" />
                  <circle cx="100" cy="140" r="3" fill="black" />
                  <text x="120" y="200" text-anchor="middle" font-family="sans-serif" font-size="20" fill="black">(1)</text>
                  <line x1="150" y1="152" x2="240" y2="128" stroke="red" stroke-width="1" style="marker-end: url(#flechaRojaFin1)" />

                  <text x="85" y="120" text-anchor="middle" transform="rotate(-90 85 120)" font-family="sans-serif" font-size="20" fill="black">dir_y</text>
                  <line x1="100" y1="140" x2="100" y2="100" stroke="red" stroke-width="1" style="marker-end: url(#flechaRojaFin1)" />
                  <text x="175" y="90" text-anchor="middle" font-family="sans-serif" font-size="20" fill="black">dir_x</text>
                  <line x1="100" y1="100" x2="250" y2="100" stroke="red" stroke-width="1" style="marker-end: url(#flechaRojaFin1)" />

                  <rect x="250" y="100" width="40" height="40" fill="red" />
                  <circle cx="250" cy="100" r="3" fill="black" />
                  <text x="270" y="160" text-anchor="middle" font-family="sans-serif" font-size="20" fill="black">(2)</text>
                  <line x1="300" y1="112" x2="390" y2="88" stroke="red" stroke-width="1" style="marker-end: url(#flechaRojaFin1)" />

                  <text x="235" y="80" text-anchor="middle" transform="rotate(-90 235 80)" font-family="sans-serif" font-size="20" fill="black">dir_y</text>
                  <line x1="250" y1="100" x2="250" y2="60" stroke="red" stroke-width="1" style="marker-end: url(#flechaRojaFin1)" />
                  <text x="325" y="50" text-anchor="middle" font-family="sans-serif" font-size="20" fill="black">dir_x</text>
                  <line x1="250" y1="60" x2="400" y2="60" stroke="red" stroke-width="1" style="marker-end: url(#flechaRojaFin1)" />

                  <rect x="400" y="60" width="40" height="40" fill="red" />
                  <circle cx="400" cy="60" r="3" fill="black" />
                  <text x="420" y="120" text-anchor="middle" font-family="sans-serif" font-size="20" fill="black">(3)</text>
                </svg>
              </p>
              <div class="codigo">
                <pre class="line-numbers" data-start="32">
<code class="language-python">    def mover(self):
        self.x += self.dir_x
        self.y += self.dir_y</code>
</pre>
              </div>
            </li>
          </ul>
        </li>
        <li>Creación de la pelota
          <p>Una vez definida una clase, en el cuerpo del programa podemos crear objetos (es decir, variables) de esa clase. En este caso, creamos la variable <i>pelota</i> de la clase <i>PelotaPong</i>. Esta variable automáticamente tendrá los atributos definidos en la clase (imagen, tamaño, posición, dirección) y se le podrán aplicar los métodos definidos en la clase (<i>mover()</i>). Al crear la variable le debemos indicar el fichero de imagen a utilizar, en este caso una imagen png.</p>
          <div class="codigo">
            <pre class="line-numbers" data-start="45">
<code class="language-python">    pelota = PelotaPong("bola_roja.png")</code>
</pre>
          </div>
        </li>
        <li>Mover la pelota
          <p>Para que la pelota se mueva y se dibuje en la pantalla, en el bucle principal del programa debemos:</p>
          <ul>
            <li>Llamar al método <i>mover()</i>, para que se modifique la posición de la pelota (es decir sus atributos <i>x</i> e <i>y</i>):
              <div class="codigo">
                <pre class="line-numbers" data-start="50">
<code class="language-python">        pelota.mover()</code>
</pre>
              </div>
            </li>
            <li>Dibujar la pelota en su posición en la ventana. Para ello recurrimos al método <i>bit()</i> del objeto ventana, indicando la imagen que queremos dibujar y su posición en la ventana:
              <div class="codigo">
                <pre class="line-numbers" data-start="53">
<code class="language-python">        ventana.blit(pelota.imagen, (pelota.x, pelota.y))</code>
</pre>
              </div>
            </li>
          </ul>
        </li>
      </ul>
    </section>

    <section id="programacion-3">
      <h3>Paso 3: Rebote de la pelota</h3>

      <p>En este paso mejoraremos el comportamiento de la pelota haciendo que la pelota rebote al chocar con los cuatro lados de la ventana. Para ello, añadiremos un nuevo método a la clase (<i>rebotar()</i>) que utilizaremos en el bucle principal del programa.</p>

      <div class="codigo copy">
        <pre class="line-numbers">
<code class="language-python"># pong_1_3.py: Rebote de la pelota

import random
import pygame
from pygame.locals import QUIT

# Constantes para la inicialización de la superficie de dibujo
VENTANA_HORI = 800  # Ancho de la ventana
VENTANA_VERT = 600  # Alto de la ventana
FPS = 60  # Fotogramas por segundo
BLANCO = (255, 255, 255)  # Color del fondo de la ventana (RGB)


class PelotaPong:
    def __init__(self, fichero_imagen):
        # --- Atributos de la Clase ---

        # Imagen de la Pelota
        self.imagen = pygame.image.load(fichero_imagen).convert_alpha()

        # Dimensiones de la Pelota
        self.ancho, self.alto = self.imagen.get_size()

        # Posición de la Pelota
        self.x = VENTANA_HORI / 2 - self.ancho / 2
        self.y = VENTANA_VERT / 2 - self.alto / 2

        # Dirección de movimiento de la Pelota
        self.dir_x = random.choice([-5, 5])
        self.dir_y = random.choice([-5, 5])

    def mover(self):
        self.x += self.dir_x
        self.y += self.dir_y

    def rebotar(self):
        if self.x &lt;= 0:
            self.dir_x = -self.dir_x
        if self.x + self.ancho &gt;= VENTANA_HORI:
            self.dir_x = -self.dir_x
        if self.y &lt;= 0:
            self.dir_y = -self.dir_y
        if self.y + self.alto &gt;= VENTANA_VERT:
            self.dir_y = -self.dir_y


def main():
    # Inicialización de Pygame
    pygame.init()

    # Inicialización de la superficie de dibujo (display surface)
    ventana = pygame.display.set_mode((VENTANA_HORI, VENTANA_VERT))
    pygame.display.set_caption("Pong 3")

    pelota = PelotaPong("bola_roja.png")

    # Bucle principal
    jugando = True
    while jugando:
        pelota.mover()
        pelota.rebotar()

        ventana.fill(BLANCO)
        ventana.blit(pelota.imagen, (pelota.x, pelota.y))

        for event in pygame.event.get():
            if event.type == QUIT:
                jugando = False

        pygame.display.flip()
        pygame.time.Clock().tick(FPS)

    pygame.quit()


if __name__ == "__main__":
    main()</code>
</pre>
      </div>

      <p>Las instrucciones añadidas con respecto al paso 2 son las siguientes:</p>
      <ul>
        <li>Método <i>rebotar()</i>:
          <p>Para conseguir que la pelota rebote contra las paredes, basta con detectar cuando la pelota llega al borde de la ventana y en ese momento cambiar la dirección del movimiento.</p>
          <ul>
            <li>Al comprobar si se ha llegado al borde, es mejor hacer las comparaciones utilizando desigualdades (&gt; o &lt;) en vez de igualdades (==), ya que la pelota se desplaza varios píxeles a cada paso y podría saltarse el valor límite. Al escribir desigualdades, nos aseguramos de que detectamos si se supera el valor límite.</li>
            <li>Como se ha comentado al colocar la pelota en el centro de la pantalla, la posición de un objeto corresponde a la posición de la esquina superior izquierda de la imagen. Por ello no es lo mismo detectar que se ha llegado al lado izquierdo de la ventana que al derecho. En el lado izquierdo podemos comparar la posición con el valor límite (0), pero en el lado derecho tenemos que tener en cuenta el ancho de la pelota. Ocurre lo mismo en vertical, puesto que abajo hay que tener en cuenta el alto de la pelota.</li>
            <li>Cuando se choca con los lados derecho e izquierdo, sólo hay que cambiar la dirección horizontal de movimiento, mientras que cuando se choca con los lados de arriba y de abajo, sólo hay que cambiar la dirección vertical.</li>
          </ul>

          <p class="mcl-svg-figura">
            <svg version="1.1" xmlns="http://www.w3.org/2000/svg" width="820" height="220" viewBox="-10 -10 820 220" style="background-color: #eeeeee">
              <rect x="0" y="0" width="800" height="200" fill="white" stroke-width="1" stroke="black" />

              <rect x="0" y="100" width="25" height="25" fill="red" />
              <circle cx="0" cy="100" r="3" fill="black" />
              <text x="35" y="100" font-family="sans-serif" font-size="20" fill="black">self.x &lt; 0</text>
              <polyline points="70,170 0,100 70,30" fill="none" stroke-width="1" stroke="black" />
              <polyline points="60,150 50,150 50,160" fill="none" stroke-width="1" stroke="black" />
              <polyline points="40,50 50,50 50,60" fill="none" stroke-width="1" stroke="black" />

              <rect x="250" y="0" width="25" height="25" fill="red" />
              <circle cx="250" cy="0" r="3" fill="black" />
              <text x="210" y="70" font-family="sans-serif" font-size="20" fill="black">self.y &lt; 0</text>
              <polyline points="180,70 250,0 320,70" fill="none" stroke-width="1" stroke="black" />
              <polyline points="200,40 210,40 210,50" fill="none" stroke-width="1" stroke="black" />
              <polyline points="280,40 290,40 290,30" fill="none" stroke-width="1" stroke="black" />

              <rect x="450" y="175" width="25" height="25" fill="red" />
              <circle cx="450" cy="175" r="3" fill="black" />
              <text x="110" y="180" font-family="sans-serif" font-size="20" fill="black">self.y + self.alto &gt; VENTANA_VERT</text>
              <polyline points="390,115 450,175 510,115" fill="none" stroke-width="1" stroke="black" />
              <polyline points="400,135 410,135 410,125" fill="none" stroke-width="1" stroke="black" />
              <polyline points="480,135 490,135 490,145" fill="none" stroke-width="1" stroke="black" />

              <rect x="775" y="100" width="25" height="25" fill="red" />
              <circle cx="775" cy="100" r="3" fill="black" />
              <text x="420" y="100" font-family="sans-serif" font-size="20" fill="black">self.x + self.ancho &gt; VENTANA_HORI</text>
              <polyline points="705,30 775,100 705,170" fill="none" stroke-width="1" stroke="black" />
              <polyline points="735,50 735,60 725,60" fill="none" stroke-width="1" stroke="black" />
              <polyline points="735,130 735,140 745,140" fill="none" stroke-width="1" stroke="black" />
            </svg>
          </p>

          <div class="codigo">
            <pre class="line-numbers" data-start="36">
<code class="language-python">    def rebotar(self):
        if self.x &lt;= 0:
            self.dir_x = -self.dir_x
        if self.x + self.ancho &gt;= VENTANA_HORI:
            self.dir_x = -self.dir_x
        if self.y &lt;= 0:
            self.dir_y = -self.dir_y
        if self.y + self.alto &gt;= VENTANA_VERT:
            self.dir_y = -self.dir_y</code>
</pre>
          </div>
        </li>
        <li>Comprobación del rebote:
          <p>Para que el programa compruebe si se debe producir un rebote basta con llamar al método en el bucle principal del programa:</p>
          <div class="codigo">
            <pre class="line-numbers" data-start="61">
<code class="language-python">    pelota.rebotar()</code>
</pre>
          </div>
        </li>
      </ul>
    </section>

    <section id="programacion-4">
      <h3>Paso 4: Reiniciar pelota al salir por los lados izquierdo y derecho</h3>

      <p>Realmente, en el juego de Pong la pelota no debe rebotar en todos los lados, como hacía en el programa anterior. Únicamente debe rebotar arriba y abajo. Si la pelota llega a alguno de los lados, significará que uno de los jugadores no ha devuelto la pelota. En ese caso, el jugador habrá perdido un punto y la pelota debe volver a lanzarse desde el centro (en dirección al jugador que ha ganado el punto, por ejemplo).</p>

      <p>En este paso, modificaremos el método <i>rebotar()</i> y añadiremos un método <i>reiniciar()</i> para conseguir el comportamiento comentado en el párrafo anterior.</p>

      <div class="codigo copy">
        <pre class="line-numbers">
<code class="language-python"># pong_1_4.py: Reiniciar pelota al salir por los lados

import random
import pygame
from pygame.locals import QUIT

# Constantes para la inicialización de la superficie de dibujo
VENTANA_HORI = 800  # Ancho de la ventana
VENTANA_VERT = 600  # Alto de la ventana
FPS = 60  # Fotogramas por segundo
BLANCO = (255, 255, 255)  # Color del fondo de la ventana (RGB)


class PelotaPong:
    def __init__(self, fichero_imagen):
        # --- Atributos de la Clase ---

        # Imagen de la Pelota
        self.imagen = pygame.image.load(fichero_imagen).convert_alpha()

        # Dimensiones de la Pelota
        self.ancho, self.alto = self.imagen.get_size()

        # Posición de la Pelota
        self.x = VENTANA_HORI / 2 - self.ancho / 2
        self.y = VENTANA_VERT / 2 - self.alto / 2

        # Dirección de movimiento de la Pelota
        self.dir_x = random.choice([-5, 5])
        self.dir_y = random.choice([-5, 5])

    def mover(self):
        self.x += self.dir_x
        self.y += self.dir_y

    def rebotar(self):
        if self.x &lt;= -self.ancho:
            self.reiniciar()
        if self.x &gt;= VENTANA_HORI:
            self.reiniciar()
        if self.y &lt;= 0:
            self.dir_y = -self.dir_y
        if self.y + self.alto &gt;= VENTANA_VERT:
            self.dir_y = -self.dir_y

    def reiniciar(self):
        self.x = VENTANA_HORI / 2 - self.ancho / 2
        self.y = VENTANA_VERT / 2 - self.alto / 2
        self.dir_x = -self.dir_x
        self.dir_y = random.choice([-5, 5])


def main():
    # Inicialización de Pygame
    pygame.init()

    # Inicialización de la superficie de dibujo (display surface)
    ventana = pygame.display.set_mode((VENTANA_HORI, VENTANA_VERT))
    pygame.display.set_caption("Pong 4")

    pelota = PelotaPong("bola_roja.png")

    # Bucle principal
    jugando = True
    while jugando:
        pelota.mover()
        pelota.rebotar()

        ventana.fill(BLANCO)
        ventana.blit(pelota.imagen, (pelota.x, pelota.y))

        for event in pygame.event.get():
            if event.type == QUIT:
                jugando = False

        pygame.display.flip()
        pygame.time.Clock().tick(FPS)

    pygame.quit()


if __name__ == "__main__":
    main()</code>
</pre>
      </div>

      <p>Las instrucciones añadidas con respecto al paso 3 son las siguientes:</p>
      <ul>
        <li>Método <i>reiniciar()</i>:
          <p>Cuando la pelota se salga por los lados izquierdo y derecho, debe volver al centro, moviéndose en dirección contraria a la que tenía antes. para ello creamos un método <i>reiniciar()</i> que modifica los atributos de posición y dirección de movimiento.</p>
          <div class="codigo">
            <pre class="line-numbers" data-start="46">
<code class="language-python">    def reiniciar(self):
        self.x = VENTANA_HORI / 2 - self.ancho / 2
        self.y = VENTANA_VERT / 2 - self.alto / 2
        self.dir_x = -self.dir_x
        self.dir_y = random.choice([-5, 5])</code>
</pre>
          </div>
        </li>
        <li>Método <i>rebotar()</i>:
          <p>Modificamos el método <i>rebotar()</i>, de manera que cuando detecte que la pelota ha salido por los lados derecho e izquierdo, llame al método <i>reiniciar()</i>.</p>
          <div class="codigo">
            <pre class="line-numbers" data-start="36">
<code class="language-python">    def rebotar(self):
        if self.x &lt;= -self.ancho:
            self.reiniciar()
        if self.x &gt;= VENTANA_HORI:
            self.reiniciar()
        if self.y &lt;= 0:
            self.dir_y = -self.dir_y
        if self.y + self.alto &gt;= VENTANA_VERT:
            self.dir_y = -self.dir_y</code>
</pre>
          </div>
        </li>
      </ul>
    </section>

    <section id="programacion-5">
      <h3>Paso 5: Clase RaquetaPong</h3>

      <p>En este paso añadiremos las raquetas. Para ello definiremos una clase <i>RaquetaPong</i>, similar a <i>PelotaPong</i> y crearemos dos variables de esa clase.</p>

      <div class="codigo copy">
        <pre class="line-numbers">
<code class="language-python"># pong_1_5.py: Clase RaquetaPong

import random
import pygame
from pygame.locals import QUIT

# Constantes para la inicialización de la superficie de dibujo
VENTANA_HORI = 800  # Ancho de la ventana
VENTANA_VERT = 600  # Alto de la ventana
FPS = 60  # Fotogramas por segundo
BLANCO = (255, 255, 255)  # Color del fondo de la ventana (RGB)


class PelotaPong:
    def __init__(self, fichero_imagen):
        # --- Atributos de la Clase ---

        # Imagen de la Pelota
        self.imagen = pygame.image.load(fichero_imagen).convert_alpha()

        # Dimensiones de la Pelota
        self.ancho, self.alto = self.imagen.get_size()

        # Posición de la Pelota
        self.x = VENTANA_HORI / 2 - self.ancho / 2
        self.y = VENTANA_VERT / 2 - self.alto / 2

        # Dirección de movimiento de la Pelota
        self.dir_x = random.choice([-5, 5])
        self.dir_y = random.choice([-5, 5])

    def mover(self):
        self.x += self.dir_x
        self.y += self.dir_y

    def rebotar(self):
        if self.x &lt;= -self.ancho:
            self.reiniciar()
        if self.x &gt;= VENTANA_HORI:
            self.reiniciar()
        if self.y &lt;= 0:
            self.dir_y = -self.dir_y
        if self.y + self.alto &gt;= VENTANA_VERT:
            self.dir_y = -self.dir_y

    def reiniciar(self):
        self.x = VENTANA_HORI / 2 - self.ancho / 2
        self.y = VENTANA_VERT / 2 - self.alto / 2
        self.dir_x = -self.dir_x
        self.dir_y = random.choice([-5, 5])


class RaquetaPong:
    def __init__(self):
        self.imagen = pygame.image.load("raqueta.png").convert_alpha()

        # --- Atributos de la Clase ---

        # Dimensiones de la Raqueta
        self.ancho, self.alto = self.imagen.get_size()

        # Posición de la Raqueta
        self.x = 0
        self.y = VENTANA_VERT / 2 - self.alto / 2

        # Dirección de movimiento de la Raqueta
        self.dir_y = 0

    def mover(self):
        self.y += self.dir_y


def main():
    # Inicialización de Pygame
    pygame.init()

    # Inicialización de la superficie de dibujo (display surface)
    ventana = pygame.display.set_mode((VENTANA_HORI, VENTANA_VERT))
    pygame.display.set_caption("Pong 5")

    pelota = PelotaPong("bola_roja.png")

    raqueta_1 = RaquetaPong()
    raqueta_1.x = 60

    raqueta_2 = RaquetaPong()
    raqueta_2.x = VENTANA_HORI - 60 - raqueta_2.ancho

    # Bucle principal
    jugando = True
    while jugando:
        pelota.mover()
        pelota.rebotar()

        ventana.fill(BLANCO)
        ventana.blit(pelota.imagen, (pelota.x, pelota.y))
        ventana.blit(raqueta_1.imagen, (raqueta_1.x, raqueta_1.y))
        ventana.blit(raqueta_2.imagen, (raqueta_2.x, raqueta_2.y))

        for event in pygame.event.get():
            if event.type == QUIT:
                jugando = False

        pygame.display.flip()
        pygame.time.Clock().tick(FPS)

    pygame.quit()


if __name__ == "__main__":
    main()</code>
</pre>
      </div>

      <p>Las instrucciones añadidas con respecto al paso 4 son las siguientes:</p>
      <ul>
        <li>Clase RaquetaPong
          <div class="codigo">
            <pre class="line-numbers" data-start="53">
<code class="language-python">class RaquetaPong:
    def __init__(self):
        self.imagen = pygame.image.load("raqueta.png").convert_alpha()

        # --- Atributos de la Clase ---

        # Dimensiones de la Raqueta
        self.ancho, self.alto = self.imagen.get_size()

        # Posición de la Raqueta
        self.x = 0
        self.y = VENTANA_VERT / 2 - self.alto / 2

        # Dirección de movimiento de la Raqueta
        self.dir_y = 0

    def mover(self):
        self.y += self.dir_y</code>
</pre>
          </div>
          <p>La clase <i>RaquetaPong</i> es muy similar a la clase <i>PelotaPong</i>.</p>
          <ul>
            <li>El método <i>__init__()</i> de la clase <i>RaquetaPong</i> es un poco más simple que el de la clase <i>PelotaPong</i>.
              <ul>
                <li>Las paletas utilizarán siempre la misma imagen, por lo que no incluiremos el camino al fichero como argumento de la clase.
                  <div class="codigo">
                    <pre class="line-numbers" data-start="54">
<code class="language-python">    def __init__(self):</code>
</pre>
                  </div>
                </li>
                <li>El atributo <i>imagen</i> cargará el fichero con la imagen:
                  <div class="codigo">
                    <pre class="line-numbers" data-start="55">
<code class="language-python">        self.imagen = pygame.image.load("raqueta.png").convert_alpha()</code>
</pre>
                  </div>
                </li>
                <li>El ancho y alto de la imagen, <i>ancho</i> y <i>alto</i> se obtienen a partir del atributo <i>imagen</i> con el método <i>get_size()</i>:
                  <div class="codigo">
                    <pre class="line-numbers" data-start="60">
<code class="language-python">        self.ancho, self.alto = self.imagen.get_size()</code>
</pre>
                  </div>
                </li>
                <li>Las posiciones iniciales horizontal y vertical de la imagen, <i>x</i> e <i>y</i> que asignemos en la definición de la clase no es realmente importante, ya que cuando creemos las raquetas deberemos situarlas en posiciones distintas cambiando estos valores. Para ahorrarnos instrucciones en el cuerpo del programa, estableceremos la posición vertical centrada en la ventana (que es común a ambas raquetas).
                  <div class="codigo">
                    <pre class="line-numbers" data-start="63">
<code class="language-python">        self.x = 0
        self.y = VENTANA_VERT / 2 - self.alto / 2</code>
</pre>
                  </div>
                </li>
                <li>Como la raqueta sólo se desplaza en vertical, únicamente necesitamos el atributo <i>dir_y</i>, que guardará la dirección vertical de movimiento de la imagen. Numéricamente, serán los píxeles que se desplazará la raqueta. Inicialmente, la raqueta estará inmóvil (0):
                  <div class="codigo">
                    <pre class="line-numbers" data-start="67">
<code class="language-python">        self.dir_y = 0</code>
</pre>
                  </div>
                </li>
              </ul>
            </li>
            <li>El método <i>mover()</i> es la función que define cómo se mueve la raqueta. Aunque lo modificaremos en el paso siguiente, por el momento simplemente añadimos a la posición vertical el valor de la dirección vertical.
              <div class="codigo">
                <pre class="line-numbers" data-start="69">
<code class="language-python">    def mover(self):
        self.y += self.dir_y</code>
</pre>
              </div>
            </li>
          </ul>
        </li>
        <li>Crear las raquetas
          <p>Una vez definida la clase, en el cuerpo del programa podemos crear objetos (es decir, variables) de esa clase. En este caso, creamos dos variables <i>raqueta_1</i> y <i>raqueta_2</i> de la clase <i>RaquetaPong</i> y modificamos sus atributos <i>x</i> para situarlas en posiciones distintas. Concretamente, las situamos a 60px de los lados izquierdo y derecho.</p>
          <div class="codigo">
            <pre class="line-numbers" data-start="83">
<code class="language-python">    raqueta_1 = RaquetaPong()
    raqueta_1.x = 60

    raqueta_2 = RaquetaPong()
    raqueta_2.x = VENTANA_HORI - 60 - raqueta_2.ancho</code>
</pre>
          </div>
          <p><strong>Nota</strong>: La posición <i>x</i> podría ser un argumento del método <i>__init__()</i> para no tener que modificar el atributo nada más crear el objeto. En el caso de la primera raqueta, efectivamente podríamos hacerlo así, pero el problema es que la posición de la segunda raqueta depende del ancho de la imagen de la raqueta, que el programa no conoce antes de crear el objeto. Por eso creamos primero el objeto, para poder utilizar su tamaño en la fórmula de la posición. Es verdad que en este caso, como las dos raquetas utilizan la misma imagen podríamos utilizar el ancho de la primera raqueta, pero el problema aparecería cuando quisiéramos utilizar imágenes de raquetas distintas, como se pide en uno de los ejercicios propuestos.</p>
        </li>
        <li>Dibujar las raquetas
          <p>Para ello recurrimos al método <i>bit()</i> del objeto ventana, indicando la imagen que queremos dibujar y su posición en la ventana:</p>
          <div class="codigo">
            <pre class="line-numbers" data-start="97">
<code class="language-python">        ventana.blit(raqueta_1.imagen, (raqueta_1.x, raqueta_1.y))
        ventana.blit(raqueta_2.imagen, (raqueta_2.x, raqueta_2.y))</code>
</pre>
          </div>
        </li>
      </ul>
    </section>

    <section id="programacion-6">
      <h3>Paso 6: Mover raqueta con teclado</h3>

      <p>En este paso, añadiremos el movimiento de la raqueta del jugador humano.</p>

      <p>El jugador humano va a controlar su raqueta (por ejemplo, la raqueta <i>raqueta_1</i>) mediante el teclado, concretamente la raqueta subirá al pulsar la tecla "w" y la raqueta "bajará" al pulsar la tecla "s". Para ello, no es necesario modificar la clase, pero en el bucle principal del programa tenemos que detectar la pulsación (y liberación) de las teclas y modificiar el atributo de dirección del movimiento.</p>

      <div class="codigo copy">
        <pre class="line-numbers">
<code class="language-python"># pong_1_6.py: Mover raqueta con teclado

import random
import pygame
from pygame.locals import QUIT

# Constantes para la inicialización de la superficie de dibujo
VENTANA_HORI = 800  # Ancho de la ventana
VENTANA_VERT = 600  # Alto de la ventana
FPS = 60  # Fotogramas por segundo
BLANCO = (255, 255, 255)  # Color del fondo de la ventana (RGB)


class PelotaPong:
    def __init__(self, fichero_imagen):
        # --- Atributos de la Clase ---

        # Imagen de la Pelota
        self.imagen = pygame.image.load(fichero_imagen).convert_alpha()

        # Dimensiones de la Pelota
        self.ancho, self.alto = self.imagen.get_size()

        # Posición de la Pelota
        self.x = VENTANA_HORI / 2 - self.ancho / 2
        self.y = VENTANA_VERT / 2 - self.alto / 2

        # Dirección de movimiento de la Pelota
        self.dir_x = random.choice([-5, 5])
        self.dir_y = random.choice([-5, 5])

    def mover(self):
        self.x += self.dir_x
        self.y += self.dir_y

    def rebotar(self):
        if self.x &lt;= -self.ancho:
            self.reiniciar()
        if self.x &gt;= VENTANA_HORI:
            self.reiniciar()
        if self.y &lt;= 0:
            self.dir_y = -self.dir_y
        if self.y + self.alto &gt;= VENTANA_VERT:
            self.dir_y = -self.dir_y

    def reiniciar(self):
        self.x = VENTANA_HORI / 2 - self.ancho / 2
        self.y = VENTANA_VERT / 2 - self.alto / 2
        self.dir_x = -self.dir_x
        self.dir_y = random.choice([-5, 5])


class RaquetaPong:
    def __init__(self):
        self.imagen = pygame.image.load("raqueta.png").convert_alpha()

        # --- Atributos de la Clase ---

        # Dimensiones de la Raqueta
        self.ancho, self.alto = self.imagen.get_size()

        # Posición de la Raqueta
        self.x = 0
        self.y = VENTANA_VERT / 2 - self.alto / 2

        # Dirección de movimiento de la Raqueta
        self.dir_y = 0

    def mover(self):
        self.y += self.dir_y
        if self.y &lt;= 0:
            self.y = 0
        if self.y + self.alto &gt;= VENTANA_VERT:
            self.y = VENTANA_VERT - self.alto


def main():
    # Inicialización de Pygame
    pygame.init()

    # Inicialización de la superficie de dibujo (display surface)
    ventana = pygame.display.set_mode((VENTANA_HORI, VENTANA_VERT))
    pygame.display.set_caption("Pong 6")

    pelota = PelotaPong("bola_roja.png")

    raqueta_1 = RaquetaPong()
    raqueta_1.x = 60

    raqueta_2 = RaquetaPong()
    raqueta_2.x = VENTANA_HORI - 60 - raqueta_2.ancho

    # Bucle principal
    jugando = True
    while jugando:
        pelota.mover()
        pelota.rebotar()
        raqueta_1.mover()

        ventana.fill(BLANCO)
        ventana.blit(pelota.imagen, (pelota.x, pelota.y))
        ventana.blit(raqueta_1.imagen, (raqueta_1.x, raqueta_1.y))
        ventana.blit(raqueta_2.imagen, (raqueta_2.x, raqueta_2.y))

        for event in pygame.event.get():
            if event.type == QUIT:
                jugando = False

            # Detecta que se ha pulsado una tecla
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_w:
                    raqueta_1.dir_y = -5
                if event.key == pygame.K_s:
                    raqueta_1.dir_y = 5

            # Detecta que se ha soltado la tecla
            if event.type == pygame.KEYUP:
                if event.key == pygame.K_w:
                    raqueta_1.dir_y = 0
                if event.key == pygame.K_s:
                    raqueta_1.dir_y = 0

        pygame.display.flip()
        pygame.time.Clock().tick(FPS)

    pygame.quit()


if __name__ == "__main__":
    main()</code>
</pre>
      </div>

      <p>Las instrucciones añadidas con respecto al paso 5 son las siguientes:</p>
      <ul>
        <li>Mover la raqueta
          <ul>
            <li>Añadimos en el bucle principal del programa la llamada al método <i>mover()</i> de la raqueta.
              <div class="codigo">
                <pre class="line-numbers" data-start="98">
<code class="language-python">        raqueta_1.mover()</code>
</pre>
              </div>
            </li>
            <li>Ahora que la raqueta se mueve, debemos impedir que se salga de la ventana. Para añadiremos en el método <i>mover()</i> dos condiciones que detecten si la raqueta se está saliendo (por arriba o por abajo).
              <div class="codigo">
                <pre class="line-numbers" data-start="69">
<code class="language-python">    def mover(self):
        self.y += self.dir_y
        if self.y &lt;= 0:
            self.y = 0
        if self.y + self.alto &gt;= VENTANA_VERT:
            self.y = VENTANA_VERT - self.alto</code>
</pre>
              </div>
            </li>
          </ul>
        </li>
        <li>Detectar las pulsaciones de teclado
          <p>Para pygame, las pulsaciones de teclado son eventos. Cuando se pulsa una tecla, pygame crea un evento <i>pygame.KEYDOWN</i> y guarda la tecla pulsada en <i>event.key</i>. Cuando se libera una tecla, pygame crea un evento <i>pygame.KEYUP</i> y guarda la tecla pulsada en <i>event.key</i>. Por ello, en el bucle <span class="idle-rese">for</span> que recorre los eventos detectados añadiremos la comprobación de los eventos y la modificación del atributo <i>dir_y</i> de dirección del movimiento.</p>
          <ul>
            <li>línea 99-100: Si se ha pulsado la tecla "w", daremos un valor negativo (por ejemplo, -5) al atributo <i>dir_y</i>, para que la raqueta se desplace hacia arriba.</li>
            <li>línea 101-102: Si se ha pulsado la tecla "s", daremos un valor positivo (por ejemplo, 5) al atributo <i>dir_y</i>, para que la raqueta se desplace hacia abajo.</li>
            <li>líneas 106-109: Si se liberan las teclas "s" y "w", daremos un valor nulo (0) al atributo <i>dir_y</i>, para detener la raqueta.</li>
          </ul>

          <div class="codigo">
            <pre class="line-numbers" data-start="109">
<code class="language-python">            # Detecta que se ha pulsado una tecla
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_w:
                    raqueta_1.dir_y = -5
                if event.key == pygame.K_s:
                    raqueta_1.dir_y = 5

            # Detecta que se ha soltado la tecla
            if event.type == pygame.KEYUP:
                if event.key == pygame.K_w:
                    raqueta_1.dir_y = 0
                if event.key == pygame.K_s:
                    raqueta_1.dir_y = 0</code>
</pre>
          </div>
        </li>
      </ul>
    </section>

    <section id="programacion-7">
      <h3>Paso 7: Golpear la pelota con la raqueta</h3>

      <p>En este paso, añadiremos el golpe de la raqueta del jugador humano a la pelota.</p>

      <p>Para ello, crearemos el método <i>golpear_raqueta()</i> en la clase <i>RaquetaPong</i> y en el bucle principal llamaremos al método.</p>

      <div class="codigo copy">
        <pre class="line-numbers">
<code class="language-python"># pong_1_7.py: Golpe raqueta jugador humano

import random
import pygame
from pygame.locals import QUIT

# Constantes para la inicialización de la superficie de dibujo
VENTANA_HORI = 800  # Ancho de la ventana
VENTANA_VERT = 600  # Alto de la ventana
FPS = 60  # Fotogramas por segundo
BLANCO = (255, 255, 255)  # Color del fondo de la ventana (RGB)


class PelotaPong:
    def __init__(self, fichero_imagen):
        # --- Atributos de la Clase ---

        # Imagen de la Pelota
        self.imagen = pygame.image.load(fichero_imagen).convert_alpha()

        # Dimensiones de la Pelota
        self.ancho, self.alto = self.imagen.get_size()

        # Posición de la Pelota
        self.x = VENTANA_HORI / 2 - self.ancho / 2
        self.y = VENTANA_VERT / 2 - self.alto / 2

        # Dirección de movimiento de la Pelota
        self.dir_x = random.choice([-5, 5])
        self.dir_y = random.choice([-5, 5])

    def mover(self):
        self.x += self.dir_x
        self.y += self.dir_y

    def rebotar(self):
        if self.x &lt;= -self.ancho:
            self.reiniciar()
        if self.x &gt;= VENTANA_HORI:
            self.reiniciar()
        if self.y &lt;= 0:
            self.dir_y = -self.dir_y
        if self.y + self.alto &gt;= VENTANA_VERT:
            self.dir_y = -self.dir_y

    def reiniciar(self):
        self.x = VENTANA_HORI / 2 - self.ancho / 2
        self.y = VENTANA_VERT / 2 - self.alto / 2
        self.dir_x = -self.dir_x
        self.dir_y = random.choice([-5, 5])


class RaquetaPong:
    def __init__(self):
        self.imagen = pygame.image.load("raqueta.png").convert_alpha()

        # --- Atributos de la Clase ---

        # Dimensiones de la Raqueta
        self.ancho, self.alto = self.imagen.get_size()

        # Posición de la Raqueta
        self.x = 0
        self.y = VENTANA_VERT / 2 - self.alto / 2

        # Dirección de movimiento de la Raqueta
        self.dir_y = 0

    def mover(self):
        self.y += self.dir_y
        if self.y &lt;= 0:
            self.y = 0
        if self.y + self.alto &gt;= VENTANA_VERT:
            self.y = VENTANA_VERT - self.alto

    def golpear(self, pelota):
        if (
            pelota.x &lt; self.x + self.ancho
            and pelota.x &gt; self.x
            and pelota.y + pelota.alto &gt; self.y
            and pelota.y &lt; self.y + self.alto
        ):
            pelota.dir_x = -pelota.dir_x
            pelota.x = self.x + self.ancho


def main():
    # Inicialización de Pygame
    pygame.init()

    # Inicialización de la superficie de dibujo (display surface)
    ventana = pygame.display.set_mode((VENTANA_HORI, VENTANA_VERT))
    pygame.display.set_caption("Pong 7")

    pelota = PelotaPong("bola_roja.png")

    raqueta_1 = RaquetaPong()
    raqueta_1.x = 60

    raqueta_2 = RaquetaPong()
    raqueta_2.x = VENTANA_HORI - 60 - raqueta_2.ancho

    # Bucle principal
    jugando = True
    while jugando:
        pelota.mover()
        pelota.rebotar()
        raqueta_1.mover()
        raqueta_1.golpear(pelota)

        ventana.fill(BLANCO)
        ventana.blit(pelota.imagen, (pelota.x, pelota.y))
        ventana.blit(raqueta_1.imagen, (raqueta_1.x, raqueta_1.y))
        ventana.blit(raqueta_2.imagen, (raqueta_2.x, raqueta_2.y))

        for event in pygame.event.get():
            if event.type == QUIT:
                jugando = False

            # Detecta que se ha pulsado una tecla
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_w:
                    raqueta_1.dir_y = -5
                if event.key == pygame.K_s:
                    raqueta_1.dir_y = 5

            # Detecta que se ha soltado la tecla
            if event.type == pygame.KEYUP:
                if event.key == pygame.K_w:
                    raqueta_1.dir_y = 0
                if event.key == pygame.K_s:
                    raqueta_1.dir_y = 0

        pygame.display.flip()
        pygame.time.Clock().tick(FPS)

    pygame.quit()


if __name__ == "__main__":
    main()</code>
</pre>
      </div>

      <p>Las instrucciones añadidas con respecto al paso 6 son las siguientes:</p>
      <ul>
        <li>Método <i>golpear()</i>
          <p>Este golpe es quizás el punto más complicado del programa.</p>
          <ul>
            <li>líneas 78 a 18: En principio, el golpe se produce cuando la raqueta y la pelota están en contacto y el resultado del golpe es que la pelota debe cambiar de dirección de movimiento horizontal.
              <p class="mcl-svg-figura">
                <svg version="1.1" xmlns="http://www.w3.org/2000/svg" width="820" height="220" viewBox="-10 -10 820 220" style="background-color: #eeeeee">
                  <rect x="0" y="0" width="800" height="200" fill="white" stroke-width="1" stroke="black" />

                  <rect x="60" y="60" width="20" height="75" fill="black" />
                  <circle cx="60" cy="60" r="3" fill="black" stroke-width="1" stroke="white" />

                  <rect x="80" y="35" width="25" height="25" fill="red" />
                  <circle cx="80" cy="35" r="3" fill="black" stroke-width="1" stroke="white" />
                  <polyline points="140,95 80,35 110,5" fill="none" stroke-width="1" stroke="black" />
                  <polyline points="115,80 115,70 125,70" fill="none" stroke-width="1" stroke="black" />
                  <polyline points="100,25 100,15 90,15" fill="none" stroke-width="1" stroke="black" />
                  <text x="120" y="30" font-family="sans-serif" font-size="20" fill="black">pelota.x &lt; self.x + self.ancho</text>
                  <text x="120" y="55" font-family="sans-serif" font-size="20" fill="black">pelota.y + pelota.alto &gt; self.y</text>

                  <rect x="80" y="135" width="25" height="25" fill="red" />
                  <circle cx="80" cy="135" r="3" fill="black" stroke-width="1" stroke="white" />
                  <polyline points="140,195 80,135 140,75" fill="none" stroke-width="1" stroke="black" />
                  <polyline points="120,185 120,175 130,175" fill="none" stroke-width="1" stroke="black" />
                  <polyline points="110,115 110,105 100,105" fill="none" stroke-width="1" stroke="black" />
                  <text x="120" y="130" font-family="sans-serif" font-size="20" fill="black">pelota.x &lt; self.x + self.ancho</text>
                  <text x="120" y="155" font-family="sans-serif" font-size="20" fill="black">pelota.y &lt; self.y + self.alto</text>
                </svg>
              </p>
            </li>
            <li>líneas 83 y 84: Para evitar que el programa detecte colisión en dos o más iteraciones consecutivas (lo que provocaría cambios continuos de dirección, es decir, el zigzazeo de la pelota), además de cambiar la dirección de movimiento de la pelota, desplazaremos explícitamente la pelota fuera de la raqueta.</li>
            <li>Un detalle que no tiene en cuenta el programa es cuando la raqueta golpea verticalmente la pelota, es decir, cuando la golpea desde abajo o desde arriba cuando está pasando. Tal y como está redactado el programa, este golpe produce la devolución de la pelota, cuando realmente no debería hacerlo.</li>
          </ul>
          <div class="codigo">
            <pre class="line-numbers" data-start="76">
<code class="language-python">    def golpear(self, pelota):
        if (
            pelota.x &lt; self.x + self.ancho
            and pelota.x &gt; self.x
            and pelota.y + pelota.alto &gt; self.y
            and pelota.y &lt; self.y + self.alto
        ):
            pelota.dir_x = -pelota.dir_x
            pelota.x = self.x + self.ancho</code>
</pre>
          </div>
        </li>
        <li>Detectar el golpe de la pelota
          <p>Añadimos en el bucle principal del programa la llamada al método <i>golpear()</i> de la raqueta del jugador humano.</p>
          <div class="codigo">
            <pre class="line-numbers" data-start="109">
<code class="language-python">        raqueta_1.golpear(pelota)</code>
</pre>
          </div>
        </li>
      </ul>
    </section>

    <section id="programacion-8">
      <h3>Paso 8: Raqueta controlada por el ordenador</h3>

      <p>En este paso, añadiremos el control de la raqueta del jugador controlado por el propio programa.</p>

      <p>Para ello, crearemos los método <i>mover_raqueta_ia()</i> y <i>golpear_raqueta_ia()</i> en la clase <i>RaquetaPong</i> y en el bucle principal llamaremos a estos métodos.</p>

      <div class="codigo copy">
        <pre class="line-numbers">
<code class="language-python"># pong_1_8.py: Jugador controlado por el programa (IA)

import random
import pygame
from pygame.locals import QUIT

# Constantes para la inicialización de la superficie de dibujo
VENTANA_HORI = 800  # Ancho de la ventana
VENTANA_VERT = 600  # Alto de la ventana
FPS = 60  # Fotogramas por segundo
BLANCO = (255, 255, 255)  # Color del fondo de la ventana (RGB)


class PelotaPong:
    def __init__(self, fichero_imagen):
        # --- Atributos de la Clase ---

        # Imagen de la Pelota
        self.imagen = pygame.image.load(fichero_imagen).convert_alpha()

        # Dimensiones de la Pelota
        self.ancho, self.alto = self.imagen.get_size()

        # Posición de la Pelota
        self.x = VENTANA_HORI / 2 - self.ancho / 2
        self.y = VENTANA_VERT / 2 - self.alto / 2

        # Dirección de movimiento de la Pelota
        self.dir_x = random.choice([-5, 5])
        self.dir_y = random.choice([-5, 5])

    def mover(self):
        self.x += self.dir_x
        self.y += self.dir_y

    def rebotar(self):
        if self.x &lt;= -self.ancho:
            self.reiniciar()
        if self.x &gt;= VENTANA_HORI:
            self.reiniciar()
        if self.y &lt;= 0:
            self.dir_y = -self.dir_y
        if self.y + self.alto &gt;= VENTANA_VERT:
            self.dir_y = -self.dir_y

    def reiniciar(self):
        self.x = VENTANA_HORI / 2 - self.ancho / 2
        self.y = VENTANA_VERT / 2 - self.alto / 2
        self.dir_x = -self.dir_x
        self.dir_y = random.choice([-5, 5])


class RaquetaPong:
    def __init__(self):
        self.imagen = pygame.image.load("raqueta.png").convert_alpha()

        # --- Atributos de la Clase ---

        # Dimensiones de la Raqueta
        self.ancho, self.alto = self.imagen.get_size()

        # Posición de la Raqueta
        self.x = 0
        self.y = VENTANA_VERT / 2 - self.alto / 2

        # Dirección de movimiento de la Raqueta
        self.dir_y = 0

    def mover(self):
        self.y += self.dir_y
        if self.y &lt;= 0:
            self.y = 0
        if self.y + self.alto &gt;= VENTANA_VERT:
            self.y = VENTANA_VERT - self.alto

    def mover_ia(self, pelota):
        if self.y &gt; pelota.y:
            self.dir_y = -3
        elif self.y &lt; pelota.y:
            self.dir_y = 3
        else:
            self.dir_y = 0

        self.y += self.dir_y

    def golpear(self, pelota):
        if (
            pelota.x &lt; self.x + self.ancho
            and pelota.x &gt; self.x
            and pelota.y + pelota.alto &gt; self.y
            and pelota.y &lt; self.y + self.alto
        ):
            pelota.dir_x = -pelota.dir_x
            pelota.x = self.x + self.ancho

    def golpear_ia(self, pelota):
        if (
            pelota.x + pelota.ancho &gt; self.x
            and pelota.x &lt; self.x + self.ancho
            and pelota.y + pelota.alto &gt; self.y
            and pelota.y &lt; self.y + self.alto
        ):
            pelota.dir_x = -pelota.dir_x
            pelota.x = self.x - pelota.ancho


def main():
    # Inicialización de Pygame
    pygame.init()

    # Inicialización de la superficie de dibujo (display surface)
    ventana = pygame.display.set_mode((VENTANA_HORI, VENTANA_VERT))
    pygame.display.set_caption("Pong 8")

    pelota = PelotaPong("bola_roja.png")

    raqueta_1 = RaquetaPong()
    raqueta_1.x = 60

    raqueta_2 = RaquetaPong()
    raqueta_2.x = VENTANA_HORI - 60 - raqueta_2.ancho

    # Bucle principal
    jugando = True
    while jugando:
        pelota.mover()
        pelota.rebotar()
        raqueta_1.mover()
        raqueta_2.mover_ia(pelota)
        raqueta_1.golpear(pelota)
        raqueta_2.golpear_ia(pelota)

        ventana.fill(BLANCO)
        ventana.blit(pelota.imagen, (pelota.x, pelota.y))
        ventana.blit(raqueta_1.imagen, (raqueta_1.x, raqueta_1.y))
        ventana.blit(raqueta_2.imagen, (raqueta_2.x, raqueta_2.y))

        for event in pygame.event.get():
            if event.type == QUIT:
                jugando = False

            # Detecta que se ha pulsado una tecla
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_w:
                    raqueta_1.dir_y = -5
                if event.key == pygame.K_s:
                    raqueta_1.dir_y = 5

            # Detecta que se ha soltado la tecla
            if event.type == pygame.KEYUP:
                if event.key == pygame.K_w:
                    raqueta_1.dir_y = 0
                if event.key == pygame.K_s:
                    raqueta_1.dir_y = 0

        pygame.display.flip()
        pygame.time.Clock().tick(FPS)

    pygame.quit()


if __name__ == "__main__":
    main()</code>
</pre>
      </div>

      <p>Las instrucciones añadidas con respecto al paso 7 son las siguientes:</p>
      <ul>
        <li>Método <i>mover_ia()</i>
          <p>El ordenador seguirá la siguiente estrategia para mover la raqueta.</p>
          <ul>
            <li>líneas 77 a 78: Si la raqueta se encuentra por debajo de la pelota, la raqueta se desplazará hacia arriba (dando un valor negativo a <i>dir_y</i>).</li>
            <li>líneas 79 a 80: Si la raqueta se encuentra por encima de la pelota, la raqueta se desplazará hacia abajo (dando un valor positivo a <i>dir_y</i>).</li>
            <li>líneas 81 a 82: Si la raqueta está a la altura de la pelota, la raqueta se detendrá (dando un valor nulo a <i>dir_y</i>).</li>
            <li>línea 76: como el método necesita conocer la posición de la pelota, incluimos la pelota como argumento del método.</li>
          </ul>
          <div class="codigo">
            <pre class="line-numbers" data-start="76">
<code class="language-python">    def mover_ia(self, pelota):
        if self.y &gt; pelota.y:
            self.dir_y = -3
        elif self.y &lt; pelota.y:
            self.dir_y = 3
        else:
            self.dir_y = 0

        self.y += self.dir_y</code>
</pre>
          </div>
        </li>
        <li>Método <i>golpear_ia()</i>
          <p>Este método es como el método <i>golpear()</i> del jugador humano, pero teniendo en cuenta que la pelota se acerca por el lado izquierdo de la raqueta en vez de por el derecho.</p>
          <div class="codigo">
            <pre class="line-numbers" data-start="96">
<code class="language-python">    def golpear_ia(self, pelota):
        if (
            pelota.x + pelota.ancho &gt; self.x
            and pelota.x &lt; self.x + self.ancho
            and pelota.y + pelota.alto &gt; self.y
            and pelota.y &lt; self.y + self.alto
        ):
            pelota.dir_x = -pelota.dir_x
            pelota.x = self.x - pelota.ancho</code>
</pre>
          </div>
        </li>
        <li>Mover la raqueta y detectar el golpe de la pelota
          <p>Añadimos en el bucle principal del programa las llamadas a los métodos <i>mover_ia()</i> y <i>golpear_ia()</i> de la raqueta del jugador controlado por el propio programa (líneas 129 y 131).</p>
          <div class="codigo">
            <pre class="line-numbers" data-start="128">
<code class="language-python">        raqueta_1.mover()
        raqueta_2.mover_ia(pelota)
        raqueta_1.golpear(pelota)
        raqueta_2.golpear_ia(pelota)</code>
</pre>
          </div>
        </li>
      </ul>
    </section>cdcd

    <section id="programacion-9">
      <h3>Paso 9: Mostrar puntuación</h3>

      <p>En este útlimo paso, añadiremos la puntuación de la partida.</p>

      <p>Para ello, crearemos unos contadores que se actualizarán al ganar uno de los dos jugadores y que se mostrarán en la ventana.</p>

      <div class="codigo copy">
        <pre class="line-numbers">
<code class="language-python"># pong_1_9.py: Mostrar puntuación de la partida

import random
import pygame
from pygame.locals import QUIT

# Constantes para la inicialización de la superficie de dibujo
VENTANA_HORI = 800  # Ancho de la ventana
VENTANA_VERT = 600  # Alto de la ventana
FPS = 60  # Fotogramas por segundo
BLANCO = (255, 255, 255)  # Color del fondo de la ventana (RGB)
NEGRO = (0, 0, 0)  # Color del texto (RGB)


class PelotaPong:
    def __init__(self, fichero_imagen):
        # --- Atributos de la Clase ---

        # Imagen de la Pelota
        self.imagen = pygame.image.load(fichero_imagen).convert_alpha()

        # Dimensiones de la Pelota
        self.ancho, self.alto = self.imagen.get_size()

        # Posición de la Pelota
        self.x = VENTANA_HORI / 2 - self.ancho / 2
        self.y = VENTANA_VERT / 2 - self.alto / 2

        # Dirección de movimiento de la Pelota
        self.dir_x = random.choice([-5, 5])
        self.dir_y = random.choice([-5, 5])

        # Puntuación de la pelota
        self.puntuacion = 0
        self.puntuacion_ia = 0

    def mover(self):
        self.x += self.dir_x
        self.y += self.dir_y

    def rebotar(self):
        if self.x &lt;= -self.ancho:
            self.reiniciar()
            self.puntuacion_ia += 1
        if self.x &gt;= VENTANA_HORI:
            self.reiniciar()
            self.puntuacion += 1
        if self.y &lt;= 0:
            self.dir_y = -self.dir_y
        if self.y + self.alto &gt;= VENTANA_VERT:
            self.dir_y = -self.dir_y

    def reiniciar(self):
        self.x = VENTANA_HORI / 2 - self.ancho / 2
        self.y = VENTANA_VERT / 2 - self.alto / 2
        self.dir_x = -self.dir_x
        self.dir_y = random.choice([-5, 5])


class RaquetaPong:
    def __init__(self):
        self.imagen = pygame.image.load("raqueta.png").convert_alpha()

        # --- Atributos de la Clase ---

        # Dimensiones de la Raqueta
        self.ancho, self.alto = self.imagen.get_size()

        # Posición de la Raqueta
        self.x = 0
        self.y = VENTANA_VERT / 2 - self.alto / 2

        # Dirección de movimiento de la Raqueta
        self.dir_y = 0

    def mover(self):
        self.y += self.dir_y
        if self.y &lt;= 0:
            self.y = 0
        if self.y + self.alto &gt;= VENTANA_VERT:
            self.y = VENTANA_VERT - self.alto

    def mover_ia(self, pelota):
        if self.y &gt; pelota.y:
            self.dir_y = -3
        elif self.y &lt; pelota.y:
            self.dir_y = 3
        else:
            self.dir_y = 0

        self.y += self.dir_y

    def golpear(self, pelota):
        if (
            pelota.x &lt; self.x + self.ancho
            and pelota.x &gt; self.x
            and pelota.y + pelota.alto &gt; self.y
            and pelota.y &lt; self.y + self.alto
        ):
            pelota.dir_x = -pelota.dir_x
            pelota.x = self.x + self.ancho

    def golpear_ia(self, pelota):
        if (
            pelota.x + pelota.ancho &gt; self.x
            and pelota.x &lt; self.x + self.ancho
            and pelota.y + pelota.alto &gt; self.y
            and pelota.y &lt; self.y + self.alto
        ):
            pelota.dir_x = -pelota.dir_x
            pelota.x = self.x - pelota.ancho


def main():
    # Inicialización de Pygame
    pygame.init()

    # Inicialización de la superficie de dibujo (display surface)
    ventana = pygame.display.set_mode((VENTANA_HORI, VENTANA_VERT))
    pygame.display.set_caption("Pong 9")

    # Inicialización de la fuente
    fuente = pygame.font.Font(None, 60)

    pelota = PelotaPong("bola_roja.png")

    raqueta_1 = RaquetaPong()
    raqueta_1.x = 60

    raqueta_2 = RaquetaPong()
    raqueta_2.x = VENTANA_HORI - 60 - raqueta_2.ancho

    # Bucle principal
    jugando = True
    while jugando:
        pelota.mover()
        pelota.rebotar()
        raqueta_1.mover()
        raqueta_2.mover_ia(pelota)
        raqueta_1.golpear(pelota)
        raqueta_2.golpear_ia(pelota)

        ventana.fill(BLANCO)
        ventana.blit(pelota.imagen, (pelota.x, pelota.y))
        ventana.blit(raqueta_1.imagen, (raqueta_1.x, raqueta_1.y))
        ventana.blit(raqueta_2.imagen, (raqueta_2.x, raqueta_2.y))

        texto = f"{pelota.puntuacion} : {pelota.puntuacion_ia}"
        letrero = fuente.render(texto, False, NEGRO)
        ventana.blit(letrero, (VENTANA_HORI / 2 - fuente.size(texto)[0] / 2, 50))

        for event in pygame.event.get():
            if event.type == QUIT:
                jugando = False

            # Detecta que se ha pulsado una tecla
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_w:
                    raqueta_1.dir_y = -5
                if event.key == pygame.K_s:
                    raqueta_1.dir_y = 5

            # Detecta que se ha soltado la tecla
            if event.type == pygame.KEYUP:
                if event.key == pygame.K_w:
                    raqueta_1.dir_y = 0
                if event.key == pygame.K_s:
                    raqueta_1.dir_y = 0

        pygame.display.flip()
        pygame.time.Clock().tick(FPS)

    pygame.quit()


if __name__ == "__main__":
    main()</code>
</pre>
      </div>

      <p>Las instrucciones añadidas con respecto al paso 8 son las siguientes:</p>
      <ul>
        <li>Puntuación de los jugadores
          <p>Para guardar y actualizar la puntuación de los jugadores, añadimos las siguientes instrucciones:</p>
          <ul>
            <li>Atributos <i>puntuacion</i>
              <p>Añadimos dos atributos más en la clase <i>PelotaPong</i>, <i>puntuacion</i> y <i>puntuacion_ia</i> para guardar las puntuaciones de cada jugador.</p>
              <div class="codigo">
                <pre class="line-numbers" data-start="33">
<code class="language-python">        # Puntuación de la pelota
        self.puntuacion = 0
        self.puntuacion_ia = 0</code>
</pre>
              </div>
            </li>
            <li>Modificar la puntuación
              <p>La puntuación debe modificarse cuando un jugador gana, es decir, cuando la pelota supera uno de los laterales. El programa detecta esa situación en el método <i>rebotar</i> de <i>PelotaPong</i>, así que añadimos en ese método las líneas 44 y 47.</p>
              <div class="codigo">
                <pre class="line-numbers" data-start="41">
<code class="language-python">    def rebotar(self):
        if self.x &lt;= -self.ancho:
            self.reiniciar()
            self.puntuacion_ia += 1
        if self.x &gt;= VENTANA_HORI:
            self.reiniciar()
            self.puntuacion += 1</code>
</pre>
              </div>
            </li>
          </ul>
        </li>
        <li>Para mostrar en la ventana la puntuación de ambos jugadores, añadimos las siguientes instrucciones:
          <ul>
            <li>Color del texto
              <p>Definimos el color NEGRO como constante:</p>
              <div class="codigo">
                <pre class="line-numbers" data-start="12">
<code class="language-python">NEGRO = (0, 0, 0)  # Color del texto (RGB)</code>
</pre>
              </div>
            </li>
            <li>Definición del tamaño de fuente
              <p>Creamos un objeto de clase <i>Font</i> en el que definimos el tamaño del tipo de letra (con el primer argumento podríamos elegir un tipo de letra determinado, en este caso no indicamos ninguno y por tanto pygame usará el predeterminado)</p>
              <div class="codigo">
                <pre class="line-numbers" data-start="122">
<code class="language-python">    # Inicialización de la fuente
    fuente = pygame.font.Font(None, 60)</code>
</pre>
              </div>
            </li>
            <li>Escritura en la pantalla
              <p>Para escribir la puntuación:</p>
              <ul>
                <li>línea 148: Creamos una variable con el texto a mostrar</li>
                <li>línea 149: Creamos la superficie de dibujo con el texto e indicamos el color del texto.</li>
                <li>línea 150: Dibujamos la superficie, indicando la posición (<i>x</i>, <i>y</i>). Como la posición es siempre la esquina superior izquierda, tenemos que desplazar la posición horizontal hacia la izquierda teniendo en cuenta el tamaño.</li>
              </ul>
              <div class="codigo">
                <pre class="line-numbers" data-start="148">
<code class="language-python">        texto = f"{pelota.puntuacion} : {pelota.puntuacion_ia}"
        letrero = fuente.render(texto, False, NEGRO)
        ventana.blit(letrero, (VENTANA_HORI / 2 - fuente.size(texto)[0] / 2, 50))</code>
</pre>
              </div>
            </li>
          </ul>
        </li>
      </ul>
    </section>
  </section>

  <section id="pendiente">
    <h2>Detalles pendientes</h2>

    <p>Estos son los aspectos pendientes de completar en el programa:</p>

    <ul>
      <li>En el programa actual, la raqueta puede golpear a la pelota verticalmente (desde arriba o desde abajo) y la pelota se devuelve, cuando lo que debería de hacer es cambiar de dirección vertical, pero no horizontal (y si la raqueta se mueve más rápido que la pelota en la misma dirección, no debería cambiar de dirección porque estaría empujándola).</li>
    </ul>
  </section>

  <footer>
    <p class="ultmod">Última modificación de esta página:  de mayo de 2022</p>

    <p><strong>Nota:</strong> Esta lección se basa en las actividades preparadas e impartidas por Daniel Benzal García, alumno del Máster de Secundaria, para sus prácticas del Máster realizadas en el curso 208/19 y al que agradezco su excelente disposición, trabajo y colaboración.</p>

    <p class="licencia">
      <a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/deed.es_ES"><img src="../varios/iconos/icono-cc-by-sa.svg" alt="Licencia Creative Commons" title="Licencia Creative Commons BY-SA" width="120" height="42"></a><br>
      Esta página forma parte del curso <strong><a href="https://www.mclibre.org/consultar/python/">Introducción a la programación con Python</a></strong> por <a href="https://www.mclibre.org/">Bartolomé Sintes Marco</a><br>
      que se distribuye bajo una <a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/deed.es_ES">Licencia Creative Commons Reconocimiento-CompartirIgual 4.0 Internacional (CC BY-SA 4.0)</a>.
    </p>
  </footer>
</body>
</html>
